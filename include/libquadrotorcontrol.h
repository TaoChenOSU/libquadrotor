#pragma once

#include "cmath3d/math3d.h"

typedef struct vec vec_t;
typedef struct quat quat_t;


// this is used for both setpoint and state estimate inputs.
struct state
{
	vec_t pos;
	vec_t vel;
	vec_t acc;

	quat_t quat;
	vec_t omega;
};
static inline void zero_state(struct state *s)
{
	s->pos = s->vel = s->acc = s->omega = vzero();
	s->quat = qeye();
}

// boundary between controller and power distribution.
struct accel
{
	float linear;
	vec_t angular;
};

// in both position and attitude of a quadrotor, the third axis is "special".
// for PID controller parameters, we generally want the same value for x and y
// and a different value for z.
struct xy_z {
	float xy;
	float z;
};

// based on the paper: Daniel Mellinger, Vijay Kumar:
// Minimum snap trajectory generation and control for quadrotors.
// IEEE International Conference on Robotics and Automation (ICRA), 2011.
struct ctrl_SE3_params
{
	struct {
		struct xy_z kp;
		struct xy_z ki;
		struct xy_z kd;
	} linear;

	struct {
		struct xy_z kp;
		struct xy_z ki;
		// TODO: implement lowpass filter for reliable d term on attitude rate
		// xy_z d;
	} omega;

	struct {
		struct xy_z kp;
	} attitude;

	struct vec int_linear_bound;
	struct vec int_omega_bound;
};

struct ctrl_SE3_state
{
	vec_t int_linear_err;
	vec_t int_omega_err;
};

void ctrl_SE3_default_params(struct ctrl_SE3_params *params);

void init_ctrl_SE3(struct ctrl_SE3_state *state);

struct accel ctrl_SE3(
	struct ctrl_SE3_state *state,
	struct ctrl_SE3_params const *param,
	struct state const *s, struct state const *set, float dt);

//
// Attitude rate control, aka "acrobatic mode" for human pilots
//
struct ctrl_attitude_rate_params
{
	struct xy_z kp;
	struct xy_z ki;
	// TODO: implement lowpass filter for reliable d term on attitude rate
	// vec_t kd;

	vec_t int_omega_bound;
};

struct ctrl_attitude_rate_state
{
	vec_t int_omega_err;
};


//
// Power distribution
//
struct quadrotor_physical_params
{
	float mass; // kg
	float arm_length; // length of one arm. m
	struct vec inertia; // diagonal of axis-aligned ineria matrix. kg * m^2
	float thrust_to_torque; // property of the propeller. torque = this * thrust.

	// motor_layout is one of 'x' or '+'.
	// if 'x', motor order starts at forward left (+x +y) and goes clockwise.
	// if '+', motor order starts at forward (+x) and goes clockwise.
	// motor_0_ccw is set true if the first motor in this order spins counterclockwise.
	// assumes diagonally opposed motors spin in same direction.
	char motor_layout;
	bool motor_0_ccw;
};

// compute the force to be generated by each propeller.
// output is prop_forces in newtons (kg * m/s^2)
void power_distribute_quad(
	struct accel const *acc,
	struct quadrotor_physical_params const *params,
	float prop_forces[4]);

