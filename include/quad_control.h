#pragma once

#include "math3d.h"
#include "quad_common_types.h"


// in both position and attitude of a quadrotor, the third axis is "special".
// for PID controller parameters, we generally want the same value for x and y
// and a different value for z.
struct xy_z {
	float xy;
	float z;
};

// based on the paper: Daniel Mellinger, Vijay Kumar:
// Minimum snap trajectory generation and control for quadrotors.
// IEEE International Conference on Robotics and Automation (ICRA), 2011.
struct quad_ctrl_SE3_params
{
	struct {
		struct xy_z kp;
		struct xy_z ki;
		struct xy_z kd;
	} linear;

	struct {
		struct xy_z kp;
		struct xy_z ki;
		// TODO: implement lowpass filter for reliable d term on attitude rate
		// xy_z d;
	} omega;

	struct {
		struct xy_z kp;
	} attitude;

	struct vec int_linear_bound;
	struct vec int_omega_bound;
};

struct quad_ctrl_SE3_state
{
	struct vec int_linear_err;
	struct vec int_omega_err;
};

void quad_ctrl_SE3_default_params(struct quad_ctrl_SE3_params *params);

void quad_ctrl_SE3_init(struct quad_ctrl_SE3_state *state);

struct quad_accel quad_ctrl_SE3(
	struct quad_ctrl_SE3_state *state,
	struct quad_ctrl_SE3_params const *param,
	struct quad_state const *s, struct quad_state const *set, float dt);

// Attitude control, aka "easy mode" for human pilots.
// In this mode, roll and pitch are controlled as absolute angles in body frame,
// while yaw is still controlled as yaw rate.
struct quad_ctrl_attitude_params
{
	struct {
		struct xy_z kp;
		struct xy_z ki;
		// TODO: implement lowpass filter for reliable d term on attitude rate
		// xy_z d;
	} omega;

	struct {
		struct xy_z kp;
	} attitude;

	struct vec int_linear_bound;
	struct vec int_omega_bound;
};

// manual pilot controls roll & pitch via absolute angles (right stick)
// but controls world csys yaw via rate (horiz axis of left stick).
// assuming the caller integrates the yaw rate control,
// convert these to a desired rotation matrix.
// all should be given in radians.
/*
struct mat33 quad_sticks2mat(
	float stick_roll, float stick_pitch, float stick_yaw_integral)
{
	// compute the unit vector implied by the stick roll and pitch angles
	float const y = sin(stick_roll);
	float const x = sin(stick_pitch);
	float const z = sqrtf(1.0f - x*x - y*y);

	
}
*/

struct quad_ctrl_attitude_state
{
	struct vec int_omega_err;
};

void quad_ctrl_attitude_default_params(struct quad_ctrl_attitude_params *params);

void quad_ctrl_attitude_init(struct quad_ctrl_attitude_state *state);

// setpoint is matrix + thrust.
// in typical manual piloting, roll & pitch angle are controlled by one stick
// and yaw *rate* is controlled by the other.
// to implement this,
struct quad_accel quad_ctrl_attitude(
	struct quad_ctrl_attitude_state *state,
	struct quad_ctrl_attitude_params const *param,
	struct quad_state const *s, struct quad_state const *set, float thrust_set, float dt);

//
// Attitude rate control, aka "acrobatic mode" for human pilots
//
struct quad_ctrl_attitude_rate_params
{
	struct xy_z kp;
	struct xy_z ki;
	// TODO: implement lowpass filter for reliable d term on attitude rate
	// struct vec kd;

	struct vec int_omega_bound;
};

struct quad_ctrl_attitude_rate_state
{
	struct vec int_omega_err;
};

struct quad_accel quad_ctrl_attitude_rate(
	struct quad_ctrl_attitude_rate_state *state,
	struct quad_ctrl_attitude_rate_params const *param,
	struct vec s, struct vec set, float thrust, float dt);

// compute the force to be generated by each propeller.
// output is prop_forces in newtons (kg * m/s^2)
void quad_power_distribute(
	struct quad_accel const *acc,
	struct quad_physical_params const *params,
	float prop_forces[4]);

